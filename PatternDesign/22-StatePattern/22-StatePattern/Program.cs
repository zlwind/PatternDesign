using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace _22_StatePattern
{
  //  状态模式
  //  核心思想是允许一个对象在它的内部状态改变时改变它的行为，即不同的状态对应不同的行为。
  //状态模式的针对性很强，当有状态变化的时候可以选择状态模式。

  //  状态模式参与者：
  //◊ Context：状态管理器
  //  ° 定义对Client感兴趣的接口
  //  ° 维持一个ConcreteState子类的实例，这个实例定义当前状态
  //◊ State：状态，定义一个接口以封装与Context的一个特定状态相关的行为。
  //◊ ConcreteState：具体状态子类，每一子类实现的一个与Context的一个状态相关的行为。
    class Program
    {
        static void Main(string[] args)
        {
            // 开一个新的账户
            Account account = new Account("Learning Hard");

            // 进行交易
            // 存钱
            account.Deposit(1000.0);
            account.Deposit(200.0);
            account.Deposit(600.0);

            // 付利息
            account.PayInterest();

            // 取钱
            account.Withdraw(2000.00);
            account.Withdraw(500.00);

            // 等待用户输入
            Console.ReadKey();
        }
    }
}
//状态者模式的应用场景
//   在以下情况下可以考虑使用状态者模式。
//       当一个对象状态转换的条件表达式过于复杂时可以使用状态者模式。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简单化。
//       当一个对象行为取决于它的状态，并且它需要在运行时刻根据状态改变它的行为时，就可以考虑使用状态者模式。
//状态者模式的优缺点
//  状态者模式的主要优点是：
//    将状态判断逻辑每个状态类里面，可以简化判断的逻辑。
//    当有新的状态出现时，可以通过添加新的状态类来进行扩展，扩展性好。
//  状态者模式的主要缺点是：
//    如果状态过多的话，会导致有非常多的状态类，加大了开销。


 //状态模式效果：
 // 1>、状态模式的本质是将条件语句的各个分支封装起来，从而实现了状态逻辑与动作的分离。当分支很多时，状态模式可以给代码的维护带来很大的便利。
 // 2>、多态性的实现。
 // 3>、状态转换的显示化。状态模式将状态的切换逻辑存放到状态对象中，可以实现状态的自动切换，使各个状态界限分明，相互独立。
 // 4>、采用分支结构时，Context对象需要关心所有状态的切换逻辑，当分支越来越多时，复杂度也会越来越大。而状态模式中Context无需关心状态的切换逻辑，
 //       每个状态对象也只需关心状态的下一个可能状态的切换逻辑。