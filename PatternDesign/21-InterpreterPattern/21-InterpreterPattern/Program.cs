using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
using _21_InterpreterPattern_1;

namespace _21_InterpreterPattern
{
    //解释器模式
    //给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。

    //1，解释器模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的模式不断重复出现，
    //   并且容易抽象为语法规则的问题”才适合使用解释器模式
    //2，解释器设计模式每个解释的类有自己的规则，并且与其他业务规则不冲突


    //可以看出，在解释器模式的结构图有以下角色：
 
    //（1）、抽象表达式(AbstractExpression)：定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，
    //       它是专门用来解释该解释器所要实现的功能。

    //（2）、终结符表达式(Terminal Expression)：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；
    //       文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，
    //       对应的解析R1和R2的解释器就是终结符表达式。

    //（3）、非终结符表达式(Nonterminal Expression)：文法中的每一条规则都需要一个具体的非终结符表达式，
    //       非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。

    //（4）、环境角色(Context)：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，
    //       我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。

    //（5）、客户端（Client）：指的是使用解释器的客户端，通常在这里将按照语言的语法做的表达式转换成使用解释器对象描述的抽象语法树，然后调用解释操作。


    class Program
    {
        static void Main(string[] args)
        {
            string roman = "五亿七千三百零二万六千四百五十二";
            //分解：((五)亿)((七千)(三百)(零)(二)万)
            //((六千)(四百)(五十)(二))

            Context context = new Context(roman);
            ArrayList tree = new ArrayList();

            tree.Add(new GeExpression());
            tree.Add(new ShiExpression());
            tree.Add(new BaiExpression());
            tree.Add(new QianExpression());
            tree.Add(new WanExpression());
            tree.Add(new YiExpression());

            foreach (Expression exp in tree)
            {
                exp.Interpreter(context);
            }

            Console.Write(context.Data);
            Console.WriteLine();
            //Console.Read();

            Program1 p1 = new Program1();
            p1.Client();
           
        }
    }
}
//https://www.cnblogs.com/PatrickLiu/p/8242238.html
//一、解释器模式的实现要点：

//    使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧方便地“扩展”文法。

//  Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。

//    （1）、解释器模式的主要优点有：

//        1】、易于改变和扩展文法。

//        2】、每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。

//        3】、实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，
//             这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。

//        4】、增加新的解释表达式较为方便。
//             如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”

// （2）、解释器模式的主要缺点有：

//        1】、对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，
//             因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。

//        2】、执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。

//    （3）、在下面的情况下可以考虑使用解释器模式：

//        Interpreter模式的应用场合是Interpreter模式应用中的难点，
//        只有满足“业务规则频繁变化，且类似的模式不断重复出现，并且容易抽象为语法规则的问题”才适合使用Interpreter模式。

//        1】、当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域）

//        2】、一些重复出现的问题可以用一种简单的语言来进行表达。

//        3】、一个语言的文法较为简单.

//        4】、当执行效率不是关键和主要关心的问题时可考虑解释器模式
//            （注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）

//二、总结

//    解释器模式可以和其他模式混合使用，具体的使用方法和解决的问题我列出了一个表，大家好好了解一下，或许对大家有些帮助。列表如下：

//     （1）解释器和组合模式

//          这两种可以组合使用，一般非终结符解释器相当于组合模式中的组合对象，终结符解释器相当于叶子对象。

//     （2）解释器模式和迭代器模式

//          由于解释器模式通常使用组合模式来实现，因此在遍历整个对象结构时，可以使用迭代器模式。

//     （3）解释器模式和享元模式

//          在使用解释器模式的时候，可能会造成多个细粒度对象，如各式各样的终结符解释器，
//          而这些终结符解释器对不同的表达式来说是一样的，是可以共用的，因此可以引入享元模式来共享这些对象。

//     （4）解释器模式和访问者模式

//         在解释器模式中，语法规则和解释器对象是有对应关系的。
//         语法规则的变动意味着功能的变化。自然会导致使用不同的解释器对象；
//         而且一个语法规由可以被不同的解释器解释执行。因此在构建抽象语法树的时候，
//         如果每个节点所对应的解释器对象是固定的，这意味着该节点对应的功能是固定的，
//         那么就不得不根据需要来构建不同的抽象语法树。为了让构建的抽象语法树较为通用，
//         那就要求解释器的功能不要那么固定，要能很方便地改变解释器的功能，
//         这个时候就变成了如何能够很方便地更改树形结构中节点对象的功能了，访问者模式可以很好的实现这个功能。

